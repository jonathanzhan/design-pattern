### 观察者模式(observer pattern)概述
在现实世界中,很多对象并不是独立存在的,其中一个对象的行为发生改变可能会导致一个或者多个的其他对象的行为也发生改变。
比如微信公众号,不定时的发布一些消息,关注公众号就可以收到消息,取消关注就收不到消息。还有当我们开车到路口时，
遇到红灯会停下,绿灯则通行等等
在软件世界也是这样,比如图表中的数据与折线图,饼状图,柱状图之间的关系，MVC模式中的模型与视图的关系，比如发布订阅模式等等。

#### 定义
观察者(observer)模式的定义是指多个对象间存在一对多的依赖关系,当一个对象的状态发生改变,所有依赖于它的对象都得到通知并被自动更新。
这种模式又被称作发布-订阅(publish-subscribe)模式,模型-视图(model/view)模式,源-监听器(source/listener)模式,
它是对象行为型模式。

#### 主要优点
1. 降低了目标与观察者之间的耦合关系,两者之间是抽象耦合关系。
2. 目标与观察者之间建立了一套触发机制。

#### 主要缺点
1. 目标与观察者之间的依赖关系并没有完全解除,而且很有可能出现循环引用。
2. 当观察者对象很多时,通知的发布会花费很多时间,影响程序效率。

### 观察者模式的结构与实现
实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用,否则将使两者之间紧密耦合起来,违反了面向对象的设计原则。

#### 结构

观察者模式的主要角色如下:
1. 抽象主题(subject)角色:也叫抽象目标类,它提供了一个用于保存观察者对象的聚集类和增加,删除观察者对象的方法,以及通知所有观察者的抽象方法。
2. 具体主题(concrete subject)角色:也叫具体目标类,它实现抽象目标中的通知方法,当具体主题的内部状态发生改变时,通知所有注册过的观察者对象。
3. 抽象观察者(observer)角色:它是一个抽象类或接口,包含了一个更新自己的抽象方法,当接收到具体主题的更改通知时被调用。
4. 具体观察者(concrete observer)角色:实现了抽象观察者定义的抽象方法,以便在得到目标的更改通知时更新自身的状态。

同时,在观察者模式,又分为推模型和拉模型两种方法。
* 推模型:主题对象向观察者对象推送主题的详细信息,不管观察者是否需要,推送的信息通常是主题对象的全部或部分数据。
* 拉模型:主题对象在通知观察者的时候,只传递少量信息,如果观察者需要更具体的信息,由观察者主动到主题对象中获取,相当于是从主题对象中拉数据。
这种模型的实现汇总,会把主题对象自身通过实现的通知方法传递给观察者,这样观察者在需要获取数据的时候,就可以通过这个引用来获取。

两种模式的比较:
推模型是假定主题对象知道观察者需要的数据,而拉模型是主题对象不知道观察者具体需要什么数据,没有办法的情况下,干脆把自身传递给观察者,让观察者自己去按需要取值。
